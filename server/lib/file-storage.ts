// Simple in-memory file storage for 24-hour access
interface StoredFile {
  content: string;
  fileName: string;
  mimeType: string;
  expiresAt: Date;
}

const fileStorage = new Map<string, StoredFile>();

export interface StoredFileInfo {
  downloadUrl: string;
  fileName: string;
  fileType: string;
}

export async function storeFileForDownload(
  jobId: number,
  fileName: string,
  content: string,
  fileType: 'pdf' | 'docx'
): Promise<StoredFileInfo> {
  // Generate unique file ID
  const fileId = `${jobId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  const downloadUrl = `/api/download/${fileId}`;
  
  // Calculate expiration time (24 hours from now)
  const expiresAt = new Date();
  expiresAt.setHours(expiresAt.getHours() + 24);
  
  // Determine MIME type
  const mimeType = fileType === 'pdf' ? 'application/pdf' : 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
  
  // Store file in memory
  fileStorage.set(fileId, {
    content,
    fileName,
    mimeType,
    expiresAt,
  });
  
  return {
    downloadUrl,
    fileName,
    fileType,
  };
}

export function getStoredFile(fileId: string): StoredFile | null {
  const file = fileStorage.get(fileId);
  if (!file || file.expiresAt < new Date()) {
    // Clean up expired file
    if (file) fileStorage.delete(fileId);
    return null;
  }
  return file;
}

// Clean up expired files periodically
setInterval(() => {
  const now = new Date();
  const keysToDelete: string[] = [];
  
  fileStorage.forEach((file, fileId) => {
    if (file.expiresAt < now) {
      keysToDelete.push(fileId);
    }
  });
  
  keysToDelete.forEach(fileId => fileStorage.delete(fileId));
}, 60 * 60 * 1000); // Clean up every hour

export async function createDownloadableFile(
  content: string,
  fileName: string,
  format: 'pdf' | 'docx' = 'pdf'
): Promise<string> {
  if (format === 'pdf') {
    // Create a simple text-based PDF with the actual resume content
    const escapedContent = content.replace(/\(/g, '\\(').replace(/\)/g, '\\)').replace(/\\/g, '\\\\');
    const lines = escapedContent.split('\n');
    
    let textObject = 'BT\n/F1 12 Tf\n72 720 Td\n';
    lines.forEach((line, index) => {
      if (line.trim()) {
        textObject += `(${line.substring(0, 80)}) Tj\n`;
        textObject += '0 -15 Td\n'; // Move to next line
      } else {
        textObject += '0 -10 Td\n'; // Smaller gap for empty lines
      }
    });
    textObject += 'ET';

    const pdfContent = `%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R] /Count 1 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>
endobj
4 0 obj
<< /Length ${textObject.length} >>
stream
${textObject}
endstream
endobj
5 0 obj
<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>
endobj
xref
0 6
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000000115 00000 n 
0000000265 00000 n 
0000000${(400 + textObject.length).toString().padStart(3, '0')} 00000 n 
trailer
<< /Size 6 /Root 1 0 R >>
startxref
${500 + textObject.length}
%%EOF`;
    return Buffer.from(pdfContent).toString('base64');
  } else {
    // Create a proper DOCX-like text file with the resume content
    const docxContent = `OPTIMIZED RESUME
================

${content}

Generated by UpMySalary Resume Optimizer
${new Date().toLocaleDateString()}`;
    return Buffer.from(docxContent).toString('base64');
  }
}