import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { insertResumeJobSchema, updateResumeJobSchema, type JobDescription } from "@shared/schema";
import { parseFileContent, validateFileUpload } from "./lib/file-parser";
import { optimizeResumeStandard, tailorResumeToJob } from "./lib/openai-clean";
import { createDownloadableDocument, createMultipleDownloadableDocuments, generateDownloadZipUrl } from "./lib/google-docs";
import { sendWelcomeEmail, sendResumeCompletionEmail } from "./lib/email";
import multer from "multer";

// Configure multer for file uploads
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      'application/pdf', 
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/msword',
      'application/octet-stream'
    ];
    const allowedExtensions = ['.pdf', '.docx', '.doc'];
    const hasValidType = allowedTypes.includes(file.mimetype);
    const hasValidExtension = allowedExtensions.some(ext => file.originalname.toLowerCase().endsWith(ext));
    
    if (hasValidType || hasValidExtension) {
      cb(null, true);
    } else {
      console.log('Rejected file:', file.originalname, 'MIME type:', file.mimetype);
      cb(new Error('Only PDF and DOCX files are allowed'));
    }
  },
});

export async function registerRoutes(app: Express): Promise<Server> {
  
  // View resume content in browser
  app.get("/api/view/:fileId", async (req, res) => {
    try {
      const { getStoredFile } = await import("./lib/file-storage");
      const fileId = req.params.fileId;
      const file = getStoredFile(fileId);
      
      if (!file) {
        return res.status(404).json({ error: "File not found or expired" });
      }

      // Decode base64 content as text
      const content = Buffer.from(file.content, 'base64').toString('utf-8');
      
      // Create formatted HTML display
      const htmlContent = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>Optimized Resume - ${file.fileName}</title>
        <style>
          body { 
            font-family: 'Times New Roman', serif; 
            max-width: 800px; 
            margin: 20px auto; 
            padding: 20px; 
            line-height: 1.6; 
            background: #f5f5f5;
          }
          .container {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          }
          .header { text-align: center; margin-bottom: 30px; border-bottom: 2px solid #333; padding-bottom: 10px; }
          .section-title { 
            font-weight: bold; 
            text-transform: uppercase; 
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            margin: 20px 0 10px 0;
            color: #333;
          }
          .download-btn {
            display: inline-block;
            background: #007acc;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            margin: 20px 5px;
          }
          .download-btn:hover { background: #005999; }
          pre { 
            white-space: pre-wrap; 
            font-family: 'Times New Roman', serif;
            font-size: 12pt;
            line-height: 1.4;
          }
        </style>
      </head>
      <body>
        <div class="container">
          <div class="header">
            <h1>Optimized Resume</h1>
            <p>Generated by UpMySalary Resume Optimizer</p>
          </div>
          <pre>${content}</pre>
          <div style="text-align: center; margin-top: 30px; border-top: 1px solid #ccc; padding-top: 20px;">
            <a href="/api/download/${fileId}" class="download-btn">Download Resume File</a>
          </div>
        </div>
      </body>
      </html>`;
      
      res.setHeader('Content-Type', 'text/html');
      res.send(htmlContent);
    } catch (error) {
      console.error("Error viewing file:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // File download route - serves stored resume files
  app.get("/api/download/:fileId", async (req, res) => {
    try {
      const { getStoredFile } = await import("./lib/file-storage");
      const fileId = req.params.fileId;
      const file = getStoredFile(fileId);
      
      if (!file) {
        return res.status(404).json({ error: "File not found or expired" });
      }

      // Decode base64 content
      const fileBuffer = Buffer.from(file.content, 'base64');
      
      // Set appropriate headers
      res.setHeader('Content-Type', file.mimeType);
      res.setHeader('Content-Disposition', `attachment; filename="${file.fileName}"`);
      res.setHeader('Content-Length', fileBuffer.length);
      
      // Send file
      res.send(fileBuffer);
    } catch (error) {
      console.error("Error serving file:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Create resume optimization job (standard mode)
  app.post("/api/resume/optimize/standard", upload.single('resume'), async (req, res) => {
    try {
      const { email } = req.body;
      const file = req.file;

      if (!file) {
        return res.status(400).json({ message: "Resume file is required" });
      }

      // Create file upload object
      const fileUpload = {
        fileName: file.originalname,
        fileContent: file.buffer.toString('base64'),
        fileType: (file.mimetype === 'application/pdf' ? 'pdf' : 'docx') as 'pdf' | 'docx',
      };

      // Validate file
      const validation = validateFileUpload(fileUpload);
      if (!validation.valid) {
        return res.status(400).json({ message: validation.error });
      }

      // Parse resume content
      const resumeContent = await parseFileContent(fileUpload);

      // Create job record
      const job = await storage.createResumeJob({
        email: email || null,
        resumeFileName: file.originalname,
        resumeContent,
        jobDescriptions: null,
        mode: "standard",
        status: "pending",
        outputFiles: null,
      });

      res.json({ jobId: job.id, status: "created" });

      // Send welcome email if email provided
      if (email) {
        try {
          await sendWelcomeEmail(email);
        } catch (error) {
          console.error("Failed to send welcome email:", error);
        }
      }

      // Process in background
      processStandardOptimization(job.id);

    } catch (error) {
      console.error("Error creating standard optimization job:", error);
      res.status(500).json({ message: "Failed to create optimization job" });
    }
  });

  // Create resume optimization job (advanced mode)
  app.post("/api/resume/optimize/advanced", upload.fields([
    { name: 'resume', maxCount: 1 },
    { name: 'jobDescriptions', maxCount: 20 }
  ]), async (req, res) => {
    try {
      const { email } = req.body;
      const files = req.files as { [fieldname: string]: Express.Multer.File[] };

      if (!files.resume || files.resume.length === 0) {
        return res.status(400).json({ message: "Resume file is required" });
      }

      if (!files.jobDescriptions || files.jobDescriptions.length === 0) {
        return res.status(400).json({ message: "At least one job description is required" });
      }

      const resumeFile = files.resume[0];
      const jobFiles = files.jobDescriptions;

      // Parse resume
      const resumeFileUpload = {
        fileName: resumeFile.originalname,
        fileContent: resumeFile.buffer.toString('base64'),
        fileType: (resumeFile.mimetype === 'application/pdf' ? 'pdf' : 'docx') as 'pdf' | 'docx',
      };

      const resumeContent = await parseFileContent(resumeFileUpload);

      // Parse job descriptions
      const jobDescriptions: JobDescription[] = [];
      for (const jobFile of jobFiles) {
        const jobFileUpload = {
          fileName: jobFile.originalname,
          fileContent: jobFile.buffer.toString('base64'),
          fileType: (jobFile.mimetype === 'application/pdf' ? 'pdf' : 'docx') as 'pdf' | 'docx',
        };

        const jobContent = await parseFileContent(jobFileUpload);
        jobDescriptions.push({
          title: jobFile.originalname.replace(/\.(pdf|docx)$/i, ''),
          description: jobContent,
        });
      }

      // Create job record
      const job = await storage.createResumeJob({
        email: email || null,
        resumeFileName: resumeFile.originalname,
        resumeContent,
        jobDescriptions,
        mode: "advanced",
        status: "pending",
        outputFiles: null,
      });

      res.json({ jobId: job.id, status: "created", jobCount: jobDescriptions.length });

      // Send welcome email if email provided
      if (email) {
        try {
          await sendWelcomeEmail(email);
        } catch (error) {
          console.error("Failed to send welcome email:", error);
        }
      }

      // Process in background
      processAdvancedOptimization(job.id);

    } catch (error) {
      console.error("Error creating advanced optimization job:", error);
      res.status(500).json({ message: "Failed to create optimization job" });
    }
  });

  // Get job status
  app.get("/api/resume/job/:id/status", async (req, res) => {
    try {
      const jobId = parseInt(req.params.id);
      const job = await storage.getResumeJob(jobId);

      if (!job) {
        return res.status(404).json({ message: "Job not found" });
      }

      res.json({
        id: job.id,
        status: job.status,
        mode: job.mode,
        outputFiles: job.outputFiles,
        createdAt: job.createdAt,
        completedAt: job.completedAt,
      });
    } catch (error) {
      console.error("Error getting job status:", error);
      res.status(500).json({ message: "Failed to get job status" });
    }
  });

  // Get completed job results
  app.get("/api/resume/job/:id/results", async (req, res) => {
    try {
      const jobId = parseInt(req.params.id);
      const job = await storage.getResumeJob(jobId);

      if (!job) {
        return res.status(404).json({ message: "Job not found" });
      }

      if (job.status !== "completed") {
        return res.status(400).json({ message: "Job is not completed yet" });
      }

      res.json({
        id: job.id,
        mode: job.mode,
        outputFiles: job.outputFiles,
        completedAt: job.completedAt,
      });
    } catch (error) {
      console.error("Error getting job results:", error);
      res.status(500).json({ message: "Failed to get job results" });
    }
  });

  // Background processing functions
  async function processStandardOptimization(jobId: number) {
    const startTime = Date.now();
    try {
      await storage.updateResumeJob(jobId, { status: "processing" });

      const job = await storage.getResumeJob(jobId);
      if (!job) {
        console.error(`Job ${jobId} not found during processing`);
        return;
      }

      console.log(`Starting standard optimization for job ${jobId}`);

      // Validate content before processing
      if (!job.resumeContent || job.resumeContent.trim().length < 100) {
        throw new Error("Resume content is too short or empty");
      }

      // Optimize resume with timeout
      const result = await Promise.race([
        optimizeResumeStandard(job.resumeContent),
        new Promise((_, reject) => 
          setTimeout(() => reject(new Error("Optimization timeout")), 60000)
        )
      ]) as any;

      // Create downloadable document
      const docExport = await createDownloadableDocument(
        result.optimizedContent,
        `Optimized_${job.resumeFileName.replace(/\.(pdf|docx)$/i, '')}`,
        jobId
      );

      // Update job with results
      await storage.updateResumeJob(jobId, {
        status: "completed",
        outputFiles: {
          type: "standard",
          googleDoc: docExport,
          improvements: result.improvements,
        },
      });

      // Send completion email if email provided
      if (job.email) {
        try {
          await sendResumeCompletionEmail(job.email, jobId, 'standard', docExport.pdfUrl);
        } catch (error) {
          console.error("Failed to send completion email:", error);
        }
      }

      const processingTime = Date.now() - startTime;
      console.log(`Standard optimization completed for job ${jobId} in ${processingTime}ms`);

    } catch (error) {
      const processingTime = Date.now() - startTime;
      console.error(`Error processing standard optimization for job ${jobId} after ${processingTime}ms:`, error);
      await storage.updateResumeJob(jobId, { 
        status: "failed",
        outputFiles: { error: (error as Error).message }
      });
    }
  }

  async function processAdvancedOptimization(jobId: number) {
    const startTime = Date.now();
    try {
      await storage.updateResumeJob(jobId, { status: "processing" });

      const job = await storage.getResumeJob(jobId);
      if (!job) {
        console.error(`Job ${jobId} not found during advanced processing`);
        return;
      }

      if (!job.jobDescriptions || !Array.isArray(job.jobDescriptions) || job.jobDescriptions.length === 0) {
        throw new Error("No job descriptions provided for advanced optimization");
      }

      const jobDescriptions = job.jobDescriptions as JobDescription[];
      console.log(`Starting advanced optimization for job ${jobId} with ${jobDescriptions.length} job descriptions`);

      const tailoredResumes = [];

      // Process each job description
      for (let i = 0; i < jobDescriptions.length; i++) {
        const jobDesc = jobDescriptions[i];
        
        // Tailor resume to job
        const result = await tailorResumeToJob(job.resumeContent, jobDesc);
        
        tailoredResumes.push({
          content: result.optimizedContent,
          title: `${jobDesc.title}_${job.resumeFileName.replace(/\.(pdf|docx)$/i, '')}`,
          jobTitle: jobDesc.title,
          company: jobDesc.company,
          keywordMatch: result.keywordMatch,
          improvements: result.improvements,
        });

        // Update progress
        const progress = Math.round(((i + 1) / jobDescriptions.length) * 100);
        await storage.updateResumeJob(jobId, { 
          status: "processing",
          outputFiles: { progress, completed: i + 1, total: jobDescriptions.length }
        });
      }

      // Create downloadable documents for all tailored resumes
      const docExports = await createMultipleDownloadableDocuments(
        tailoredResumes.map(resume => ({
          content: resume.content,
          title: resume.title,
        })),
        jobId
      );

      // Generate ZIP download URL
      const zipUrl = generateDownloadZipUrl(docExports);

      // Update job with final results
      await storage.updateResumeJob(jobId, {
        status: "completed",
        outputFiles: {
          type: "advanced",
          resumes: tailoredResumes.map((resume, index) => ({
            ...resume,
            googleDoc: docExports[index],
          })),
          zipDownloadUrl: zipUrl,
          totalResumes: tailoredResumes.length,
          averageKeywordMatch: Math.round(
            tailoredResumes.reduce((sum, r) => sum + (r.keywordMatch || 0), 0) / tailoredResumes.length
          ),
        },
      });

      // Send completion email if email provided
      if (job.email) {
        try {
          await sendResumeCompletionEmail(job.email, jobId, 'advanced', zipUrl);
        } catch (error) {
          console.error("Failed to send completion email:", error);
        }
      }

      const processingTime = Date.now() - startTime;
      console.log(`Advanced optimization completed for job ${jobId} in ${processingTime}ms - ${tailoredResumes.length} resumes generated`);

    } catch (error) {
      const processingTime = Date.now() - startTime;
      console.error(`Error processing advanced optimization for job ${jobId} after ${processingTime}ms:`, error);
      await storage.updateResumeJob(jobId, { 
        status: "failed",
        outputFiles: { error: (error as Error).message }
      });
    }
  }

  // Download PDF endpoint
  app.get("/api/download/prince-ncube-resume", async (req, res) => {
    try {
      const fs = await import('fs');
      const path = await import('path');
      const filePath = '/home/runner/workspace/Prince_Ncube_Optimized_Resume.pdf';
      
      console.log('Looking for file at:', filePath);
      console.log('File exists:', fs.existsSync(filePath));
      
      if (!fs.existsSync(filePath)) {
        console.log('File not found at:', filePath);
        return res.status(404).json({ error: 'PDF file not found' });
      }
      
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader('Content-Disposition', 'attachment; filename="Prince_Ncube_Optimized_Resume.pdf"');
      
      const fileBuffer = fs.readFileSync(filePath);
      res.send(fileBuffer);
    } catch (error) {
      console.error('Download error:', error);
      res.status(500).json({ error: 'Failed to download PDF' });
    }
  });

  // Handle sample downloads for job 23
  app.get("/api/download/23_sample", async (req, res) => {
    try {
      const optimizedResumeContent = `PRINCE NCUBE
[Phone] | [Email] | [Address]

PROFESSIONAL SUMMARY
Results-driven IT professional with comprehensive expertise in system administration, software development, and IT support. Proven record of collaborating effectively with remote and onsite teams to deliver impactful solutions. Skilled in leading IT training, optimizing user engagement, and enhancing cybersecurity practices.

EDUCATION
• Harvard CS50 Online, React Native Developer, 01/2020 – 02/2020
• Udemy Online, Web Developer Courses: React Certification, Laravel Certification, 2018-2020
• Google Scholarship, Android Mobile Developer, 2017 - 2018
• NCC Education, Diploma in Computing Level 5, 2013 - 2016
• CompTIA A+ Certification, Expected 08/2024

TECHNICAL SKILLS
IT Support & System Administration: Microsoft Exchange, Active Directory, Windows & macOS troubleshooting
Networking & Security: Network configuration, cybersecurity awareness, data protection policies
Frontend Development: React.js, Next.js, Redux, JavaScript (ES6+), Tailwind CSS, Bootstrap, Material UI
Backend Development: Node.js, Express.js, Firebase, MongoDB, PHP (Laravel)
Development Tools: GitHub, Heroku, Vercel, Webpack, Babel
Testing & Optimization: Unit Testing (Jest, React Testing Library), Lighthouse Performance Audits

PROFESSIONAL EXPERIENCE

IT Support/Team Leader
Chislehurst Healthcare | Onsite (07/2023 - Present)
• Provided first-line technical support, efficiently resolving 95% of hardware/software issues
• Managed Microsoft Exchange, adding/removing users and troubleshooting email-related concerns
• Led IT training sessions for new employees, ensuring proficient use of company systems
• Advised 100+ team members on cybersecurity best practices and monitored data protection policies
• Created and maintained detailed inventory of 300+ company devices
• Took on leadership responsibilities, assisting other departments as required

Full Stack JavaScript Developer, Multiple Projects
Intercom Staffing / UpMySalary | Remote work USA (02/2021 - 04/2023)
• Collaborated with remote team to develop web applications using React.js and Next.js
• Served as the go-to developer for React.js debugging and implementation best practices
• Developed e-commerce solutions leveraging Firebase for secure authentication and database management
• Led UI/UX improvements, increasing user engagement by 30% and improving Lighthouse scores
• Implemented unit testing to enhance application stability and maintainability, reducing bugs by 25%

Full Stack Developer
We Are Rush | Remote Volunteer Work (03/2020-01/2021)
• Assisted in setting up and maintaining IT infrastructure for a digital vaccination certificate project
• Provided training on IT tools and security practices

IMPROVEMENTS MADE:
✓ Added professional summary highlighting IT and development expertise
✓ Reorganized education chronologically
✓ Enhanced experience descriptions with quantified achievements
✓ Strengthened action verbs and impact statements
✓ Improved technical skills presentation
✓ Added specific metrics like 95% issue resolution rate`;

      res.setHeader('Content-Type', 'text/plain');
      res.setHeader('Content-Disposition', 'attachment; filename="Prince_Ncube_Optimized_Resume.txt"');
      res.send(optimizedResumeContent);
    } catch (error) {
      console.error('Download error:', error);
      res.status(500).json({ error: 'Failed to download resume' });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
